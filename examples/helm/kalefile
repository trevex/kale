project("simple")

kubectl = require("kubectl", { "version": ">=1.10.0" })
helm = require("helm", { "version": ">=2.12.0" })

var.extend({ # adds additional global variables
    "bar_baz": schema.string(default = "foo")
})

def prepare(params):
    chart_with_deps = helm.dep_build(chart_dir="./chart")
    output(chart_with_deps) # TODO: or just return?
    # TODO: output needs to be "Outputable"
    #       1. Create Outputable-interface
    #       2. All types should implement interface and we can check this
    #       3. Use interface to easily copy everything to output dir :)
    #       x. Create helper function wrapping compatible starlark types (necessary?)

# TODO: stages/checksum/cache-dir structure!?
#       1. The project has a reference to a stage, but it is created ahead of time
#       2. Each target added will receive a sub stage
#       3. Each call can retrieve the currently active stage via helper method
#       4. For a simple command it can create a SubStage from a checksum object and a prefix
# Refactor checksum into own package with OO-approach, e.g.
# b := checksum.NewBuilder()
# b.AddDir("test")
# b.AddFile("asd.yaml") # always use mod timestamp?
# b.AddString("asdasd")
# sha := b.Build()
# c := cache.New(prefix, sha) # checks in with project and target to see what is active (means we can remove cachedir logic from target as well?) Activate updates CacheDir?
# if c.Exists() {
#     report.SkipStep("")
# } else {
#     Do()
# }


def build(params):
    print(params)
    print(params.version)
    kubectl.apply("test")
    print("last")

target(prepare)

target(build, params = {
    "values": schema.filename(required = True),
    "version": schema.string(default = "0.9.0"),
    "b": schema.bool(default = True),
    "f": schema.float(default = 1.0),
    "i": schema.int(default = 2)
})
